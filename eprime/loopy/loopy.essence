$ loopy
$ given an n by m grid of numbers, determine the single loop they determine
$ if a number i is in a cell, then precisely i of its borders must be present
$ empty cells are represented by 0 and do not constrain borders
$ 4 represents no borders to be present in the loop (0 in original instance)

$ to enforce a single loop, it is enough to ensure that all outside regions
$ are adjacent to the cells outside the matrix,
$ AND that there is a single inside region
$ the last condition is easiest to enforce with LFP
$ we use a slower second order property, a cyclic labelling of border edges 

given n, m : int(1..)
$letting d be max({n,m})
letting rows be domain int(1..n)
letting rows0 be domain int(0..n)
letting cols be domain int(1..m)
letting cols0 be domain int(0..m)
letting HV be new type enum {H,V}
given grid : matrix indexed by [rows,cols] of int(0..4)

find edges : matrix indexed by [HV,rows0,cols0] of bool
$ edges[H,i,j] is the edge below cell i,j (south border)
$ edges[V,i,j] is the edge right of cell i,j (east border)
$ edges[H,i-1,j] is north border
$ edges[V,i,j-1] is west border
such that true
$ remove edges outside grid
, (forAll i : rows0 . edges[H,i,0] = false)
, (forAll j : cols0 . edges[V,0,j] = false)
$ each non-empty cell has the given number of borders (treat 4 as 0)
, (forAll i : rows . forAll j : cols . grid[i,j] > 0 ->
    (toInt(edges[H,i-1,j]) + toInt(edges[H,i,j])
   + toInt(edges[V,i,j]) + toInt(edges[V,i,j-1]) = (grid[i,j] % 4))
  )
$ enforce degree 2 or degree 0 for all grid corner points
, forAll i : rows . forAll j : cols .
    ( toInt(edges[H,i-1,j-1]) + toInt(edges[H,i-1,j])
    + toInt(edges[V,i-1,j-1]) + toInt(edges[V,i,j-1]) ) in {0,2}
, forAll j : cols .
    ( toInt(edges[H,n,j-1]) + toInt(edges[H,n,j])
    + toInt(edges[V,n,j-1]) ) in {0,2}
, forAll i : rows .
    ( toInt(edges[H,i-1,m])
    + toInt(edges[V,i-1,m]) + toInt(edges[V,i,m]) ) in {0,2}

$ there are 2*n*m + n + m edges in grid
letting maxEdges be 2*n*m + n + m
find q : int(4..maxEdges)
such that
  q = sum([ toInt(edges[o,i,j]) | o : HV, i : rows0 , j : cols0 ])

$ now enforce that borders form a single loop
$ this is a labelling of the q border edges with 0..q-1 such that
$ labels of adjacent edges differ by 1, modulo q
find loop : function (total) (HV,rows0,cols0) --> int(0..maxEdges)
such that true
$ can't use a computed domain bound, so enforce it explicitly instead
, forAll o : HV . forAll i : rows0 . forAll j : cols0 .
    loop((o,i,j)) <= q
$ edges not in the loop receive label q
, forAll o : HV . forAll i : rows0 . forAll j : cols0 .
    !edges[o,i,j] <-> loop((o,i,j)) = q
$ labelling is injective over the loop edges
, allDiff([ loop((o,i,j)) | o : HV, i : rows0, j : cols0, edges[o,i,j] ])
$ HH
, forAll i : rows0 . forAll j : cols .
    (edges[H,i,j-1] /\ edges[H,i,j]) ->
      (|loop((H,i,j-1)) - loop((H,i,j))| in {1,q-1})
$ VV
, forAll i : rows . forAll j : cols0 .
    (edges[V,i-1,j] /\ edges[V,i,j]) ->
      (|loop((V,i-1,j)) - loop((V,i,j))| in {1,q-1})
$ south-east borders
, forAll i : rows . forAll j : cols .
    (edges[H,i,j] /\ edges[V,i,j]) ->
      (|loop((H,i,j)) - loop((V,i,j))| in {1,q-1})
$ north-west borders
, forAll i : rows . forAll j : cols .
    (edges[H,i-1,j] /\ edges[V,i,j-1]) ->
      (|loop((H,i-1,j)) - loop((V,i,j-1))| in {1,q-1})
$ north-east borders
, forAll i : rows . forAll j : cols .
    (edges[H,i-1,j] /\ edges[V,i,j]) ->
      (|loop((H,i-1,j)) - loop((V,i,j))| in {1,q-1})
$ south-west borders
, forAll i : rows . forAll j : cols .
    (edges[H,i,j] /\ edges[V,i,j-1]) ->
      (|loop((H,i,j)) - loop((V,i,j-1))| in {1,q-1})

$ symmetry breaking
find tlr : rows
find tlc : cols
such that true
$ find leftmost cell in first row touching the loop north or west
, tlr = min([ r | r : rows, c : cols, edges[V,r,c-1]\/edges[H,r-1,c] ])
, tlc = min([ c | c : cols, edges[V,tlr,c-1]\/edges[H,tlr-1,c] ])
$ note: edges[tlr,tlc] always has both west and north borders
$ label west border 0, north border 1
, loop((V,tlr,tlc-1)) = 0
, loop((H,tlr-1,tlc)) = 1

